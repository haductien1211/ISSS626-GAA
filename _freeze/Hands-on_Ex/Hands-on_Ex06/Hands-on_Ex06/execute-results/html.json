{
  "hash": "ba418d3877425999b20b7ae9148b4421",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 6 Geographical Segmentation with Spatially Constrained Clustering Techniques\"\nauthor: \"Ha Duc Tien\"\ndate: \"September 23, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  message: false\n  freeze: true\n---\n\n\n# 1. Overview\n\nIn this hands-on exercise, we will gain hands-on experience on how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:\n\n-   hierarchical cluster analysis; and\n-   spatially constrained cluster analysis.\n\nBy the end of this hands-on exercise, we will able:\n\n-   to convert GIS polygon data into R’s simple feature data.frame by using appropriate functions of sf package of R;\n-   to convert simple feature data.frame into R’s SpatialPolygonDataFrame object by using appropriate sf of package of R;\n-   to perform custer analysis by using `hclust()` of Base R;\n-   to perform spatially constrained cluster analysis using `skater()` of Base R; and\n-   to visualise the analysis output by using `ggplot2` and `tmap` package.\n\n# 2. Getting Started\n\n## The analytical question\n\nIn geobusiness and spatial policy, it is a common practice to delineate the market or planning area into homogeneous regions by using multivariate data. In this hands-on exercise, we are interested to delineate [Shan State](https://en.wikipedia.org/wiki/Shan_State), [Myanmar](https://en.wikipedia.org/wiki/Myanmar) into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\n\n# 3. The data and Packages\n\n## 3.1 The data\n\nTwo data sets will be used in this study. They are:\n\n-   Myanmar Township Boundary Data (i.e. myanmar_township_boundaries) : This is a GIS data in ESRI shapefile format. It consists of township boundary information of Myanmar. The spatial data are captured in polygon features.\n-   Shan-ICT.csv: This is an extract of [The 2014 Myanmar Population and Housing Census Myanmar](https://myanmar.unfpa.org/en/publications/2014-population-and-housing-census-myanmar-data-sheet) at the township level.\nBoth data sets are download from [Myanmar Information Management Unit (MIMU)](https://themimu.info/)\n\n## 3.2 Installing and loading R packages\n\nBefore we get started, it is important for us to install the necessary R packages into R and launch these R packages into R environment.\n\nThe R packages needed for this exercise are as follows:\n\n-   Spatial data handling\n    -   `sf`, `rgdal` and `spdep`\n-   Attribute data handling\n    -   `tidyverse`, especially `readr`, `ggplot2` and `dplyr`\n-   Choropleth mapping\n    -   `tmap`\n-   Multivariate data visualisation and analysis\n    -   `coorplot`, `ggpubr`, and `heatmaply`\n-   Cluster analysis\n    -   `cluster`\n    -   `ClustGeo`\nThe code chunks below installs and launches these R packages into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(spdep, tmap, sf, ClustGeo, \n               ggpubr, cluster, factoextra, NbClust,\n               heatmaply, corrplot, psych, tidyverse, GGally)\n```\n:::\n\n\nNote: With `tidyverse`, we do not have to install `readr`, `ggplot2` and `dplyr` packages separately. In fact, `tidyverse` also installs other very useful R packages such as `tidyr`\n\n# 4. Data Import and Prepatation\n\n## 4.1 Importing geospatial data into R environment\n\nIn this section, we will import Myanmar Township Boundary GIS data and its associated attrbiute table into R environment.\n\nThe Myanmar Township Boundary GIS data is in ESRI shapefile format. It will be imported into R environment by using the [st_read()](https://www.rdocumentation.org/packages/sf/versions/0.7-2/topics/st_read) function of `sf`.\n\nThe code chunks used are shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf <- st_read(dsn = \"data/geospatial\", \n                   layer = \"myanmar_township_boundaries\") %>%\n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\")) %>%\n  select(c(2:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `myanmar_township_boundaries' from data source \n  `C:\\Users\\tien_\\OneDrive\\SMU\\haductien1211\\ISSS626-GAA\\Hands-on_Ex\\Hands-on_Ex06\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\nThe imported township boundary object is called shan_sf. It is saved in **simple feature data.frame** format. We can view the content of the newly created shan_sf simple features data.frame by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshan_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 55 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n             ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1  Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2  Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3  Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4  Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5  Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6  Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7  Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8  Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9  Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                         geometry\n1  MULTIPOLYGON (((96.96001 23...\n2  MULTIPOLYGON (((96.7731 21....\n3  MULTIPOLYGON (((96.78483 21...\n4  MULTIPOLYGON (((96.49518 20...\n5  MULTIPOLYGON (((96.66306 24...\n6  MULTIPOLYGON (((96.49518 20...\n7  MULTIPOLYGON (((97.14738 19...\n8  MULTIPOLYGON (((96.94981 22...\n9  MULTIPOLYGON (((96.75648 22...\n10 MULTIPOLYGON (((96.95498 22...\n```\n\n\n:::\n:::\n\n\nNotice that sf.data.frame is conformed to Hardy Wickham’s [tidy](https://edzer.github.io/rstudio_conf/#1) framework.\n\nSince shan_sf is conformed to tidy framework, we can also `glimpse()` to reveal the data type of it’s fields.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(shan_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 55\nColumns: 7\n$ ST       <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (South)…\n$ ST_PCODE <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR014\", \"…\n$ DT       <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\", \"Ta…\n$ DT_PCODE <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", \"MMR0…\n$ TS       <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"Kalaw…\n$ TS_PCODE <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR01501…\n$ geometry <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGON (((…\n```\n\n\n:::\n:::\n\n\n## 4.2 Importing aspatial data into R environment\n\nThe csv file will be import using *read_csv* function of `readr` package.\n\nThe code chunks used are shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict <- read_csv (\"data/aspatial/Shan-ICT.csv\")\n```\n:::\n\n\nThe imported InfoComm variables are extracted from **The 2014 Myanmar Population and Housing Census Myanmar**. The attribute data set is called ict. It is saved in R’s tibble *data.frame* format.\n\nThe code chunk below reveal the summary statistics of ict data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n District Pcode     District Name      Township Pcode     Township Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total households     Radio         Television    Land line phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile phone      Computer      Internet at home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n```\n\n\n:::\n:::\n\n\nThere are a total of eleven fields and 55 observation in the tibble *data.frame*.\n\n## 4.3 Derive new variables using dplyr package\n\nThe unit of measurement of the values are number of household. Using these values directly will be bias by the underlying total number of households. In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.\n\nIn order to overcome this problem, we will derive the penetration rate of each ICT variable by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land line phone`/`Total households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile phone`/`Total households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet at home`/`Total households`*1000) %>%\n  rename(`DT_PCODE` =`District Pcode`,`DT`=`District Name`,\n         `TS_PCODE`=`Township Pcode`, `TS`=`Township Name`,\n         `TT_HOUSEHOLDS`=`Total households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land line phone`, `MPHONE`=`Mobile phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet at home`) \n```\n:::\n\n\nLet us review the summary statistics of the newly derived penetration rates using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ict_derived)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   DT_PCODE              DT              TS_PCODE              TS           \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n TT_HOUSEHOLDS       RADIO             TV           LLPHONE      \n Min.   : 3318   Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711   1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685   Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369   Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471   3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604   Max.   :30176   Max.   :62388   Max.   :6736.0  \n     MPHONE         COMPUTER         INTERNET         RADIO_PR     \n Min.   :  150   Min.   :  20.0   Min.   :   8.0   Min.   : 21.05  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0   1st Qu.:138.95  \n Median : 3559   Median : 244.0   Median : 316.0   Median :210.95  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2   Mean   :215.68  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5   3rd Qu.:268.07  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0   Max.   :484.52  \n     TV_PR         LLPHONE_PR       MPHONE_PR       COMPUTER_PR    \n Min.   :116.0   Min.   :  2.78   Min.   : 36.42   Min.   : 3.278  \n 1st Qu.:450.2   1st Qu.: 22.84   1st Qu.:190.14   1st Qu.:11.832  \n Median :517.2   Median : 37.59   Median :305.27   Median :18.970  \n Mean   :509.5   Mean   : 51.09   Mean   :314.05   Mean   :24.393  \n 3rd Qu.:606.4   3rd Qu.: 69.72   3rd Qu.:428.43   3rd Qu.:29.897  \n Max.   :842.5   Max.   :181.49   Max.   :735.43   Max.   :92.402  \n  INTERNET_PR     \n Min.   :  1.041  \n 1st Qu.:  8.617  \n Median : 22.829  \n Mean   : 30.644  \n 3rd Qu.: 41.281  \n Max.   :117.985  \n```\n\n\n:::\n:::\n\n\nNotice that six new fields have been added into the *data.frame*. They are `RADIO_PR`, `TV_PR`, `LLPHONE_PR`, `MPHONE_PR`, `COMPUTER_PR`, and `INTERNET_PR`.\n\n# 5. Exploratory Data Analysis (EDA)\n\n## 5.1 EDA using statistical graphics\n\nWe can plot the distribution of the variables (i.e. Number of households with radio) by using appropriate Exploratory Data Analysis (EDA) as shown in the code chunk below.\n\nHistogram is useful to identify the overall distribution of the data values (i.e. left skew, right skew or normal distribution)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-9-1.png){width=1200}\n:::\n:::\n\n\nBoxplot is useful to detect if there are outliers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-10-1.png){width=1200}\n:::\n:::\n\n\nNext, we will also plotting the distribution of the newly derived variables (i.e. Radio penetration rate) by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-11-1.png){width=1200}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-12-1.png){width=1200}\n:::\n:::\n\n\n\nWhat can you observed from the distributions reveal in the histogram and boxplot.\n\nIn the figure below, multiple histograms are plotted to reveal the distribution of the selected variables in the ict_derived data.frame.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Hands-on_Ex06_files/figure-html/unnamed-chunk-13-1.png){width=1200}\n:::\n:::\n\n\nThe code chunks below are used to create the data visualisation. They consist of two main parts. First, we will create the individual histograms using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nradio <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ntv <- ggplot(data=ict_derived, \n             aes(x= `TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nllphone <- ggplot(data=ict_derived, \n             aes(x= `LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\nmphone <- ggplot(data=ict_derived, \n             aes(x= `MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ncomputer <- ggplot(data=ict_derived, \n             aes(x= `COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n\ninternet <- ggplot(data=ict_derived, \n             aes(x= `INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\n```\n:::\n\n\nNext, the [ggarrange()](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html) function of [ggpubr](https://rpkgs.datanovia.com/ggpubr/index.html) package is used to group these histograms together.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggarrange(radio, tv, llphone, mphone, computer, internet, \n          ncol = 3, \n          nrow = 2)\n```\n:::\n\n\n\n## 5.2 EDA using choropleth map\n\n### 5.2.1 Joining geospatial data with aspatial data\n\n",
    "supporting": [
      "Hands-on_Ex06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}