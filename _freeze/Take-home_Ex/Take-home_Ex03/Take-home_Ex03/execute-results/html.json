{
  "hash": "985ccdbed0a28987b1abac6519fed5ff",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-home Exercise 3\"\nauthor: \"Ha Duc Tien\"\ndate: \"October 21, 2024\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n# 1. Objectives and Tasks\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, httr, jsonlite, rvest, tmap)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale <- read_csv(\"data/non-geo/resale.csv\") %>%\n  filter(month >= \"2023-01\" & month <= \"2024-09\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_tidy <- resale %>%\n  mutate(address = paste(block,street_name)) %>%\n  mutate(remaining_lease_yr = as.integer(\n    str_sub(remaining_lease, 0, 2)))%>%\n  mutate(remaining_lease_mth = as.integer(\n    str_sub(remaining_lease, 9, 11)))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresale_selected <- resale_tidy %>%\n  filter(month == \"2024-09\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_list <- sort(unique(resale_selected$address))\n```\n:::\n\n\nUser `st_jitter()` to address overlapping points\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_coords <- function(add_list){\n  \n  # Create a data frame to store all retrieved coordinates\n  postal_coords <- data.frame()\n    \n  for (i in add_list){\n    #print(i)\n\n    r <- GET('https://www.onemap.gov.sg/api/common/elastic/search?',\n           query=list(searchVal=i,\n                     returnGeom='Y',\n                     getAddrDetails='Y'))\n    data <- fromJSON(rawToChar(r$content))\n    found <- data$found\n    res <- data$results\n    \n    # Create a new data frame for each address\n    new_row <- data.frame()\n    \n    # If single result, append \n    if (found == 1){\n      postal <- res$POSTAL \n      lat <- res$LATITUDE\n      lng <- res$LONGITUDE\n      new_row <- data.frame(address= i, \n                            postal = postal, \n                            latitude = lat, \n                            longitude = lng)\n    }\n    \n    # If multiple results, drop NIL and append top 1\n    else if (found > 1){\n      # Remove those with NIL as postal\n      res_sub <- res[res$POSTAL != \"NIL\", ]\n      \n      # Set as NA first if no Postal\n      if (nrow(res_sub) == 0) {\n          new_row <- data.frame(address= i, \n                                postal = NA, \n                                latitude = NA, \n                                longitude = NA)\n      }\n      \n      else{\n        top1 <- head(res_sub, n = 1)\n        postal <- top1$POSTAL \n        lat <- top1$LATITUDE\n        lng <- top1$LONGITUDE\n        new_row <- data.frame(address= i, \n                              postal = postal, \n                              latitude = lat, \n                              longitude = lng)\n      }\n    }\n\n    else {\n      new_row <- data.frame(address= i, \n                            postal = NA, \n                            latitude = NA, \n                            longitude = NA)\n    }\n    \n    # Add the row\n    postal_coords <- rbind(postal_coords, new_row)\n  }\n  return(postal_coords)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- get_coords(add_list)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(coords, \"data/rds/coords.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\neldercare <- st_read(dsn = \"data/geo\",\n                     layer = \"ELDERCARE\") %>%\n  st_transform(crs = 3414)\n```\n:::\n\nCreate a buffer of 1 km around eldercare points\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuffer_1km <- st_buffer(eldercare,\n                        dist = 1000)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nCHAS <- st_read(dsn = \"data/geo/CHASClinics.kml\") %>%\n  st_transform(crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"view\")\ntm_shape(buffer_1km) +\n  tm_polygons() +\n  tm_shape(CHAS) +\n  tm_dots()\n```\n:::\n\n\nThe code chunk below is used to count the number of CHAS Clinics with 1km of each eldercare center\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuffer_1km$pts_count <- lengths(st_intersects(buffer_1km, CHAS))\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}